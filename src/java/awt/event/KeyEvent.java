/*
 * Copyright (c) 1999, 2007, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the "Classpath" exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package java.awt.event;

import java.awt.Component;
import java.io.IOException;
import java.io.ObjectInputStream;

/**
 * An event which indicates that a keystroke occurred in a component.
 * <p>
 * This low-level event is generated by a component object (such as a text
 * field) when a key is pressed, released, or typed.
 * The event is passed to every <code>KeyListener</code>
 * or <code>KeyAdapter</code> object which registered to receive such
 * events using the component's <code>addKeyListener</code> method.
 * (<code>KeyAdapter</code> objects implement the
 * <code>KeyListener</code> interface.)  Each such listener object
 * gets this <code>KeyEvent</code> when the event occurs.
 * <p>
 * <em>"Key typed" events</em> are higher-level and generally do not depend on
 * the platform or keyboard layout.  They are generated when a Unicode character
 * is entered, and are the preferred way to find out about character input.
 * In the simplest case, a key typed event is produced by a single key press
 * (e.g., 'a').  Often, however, characters are produced by series of key
 * presses (e.g., 'shift' + 'a'), and the mapping from key pressed events to
 * key typed events may be many-to-one or many-to-many.  Key releases are not
 * usually necessary to generate a key typed event, but there are some cases
 * where the key typed event is not generated until a key is released (e.g.,
 * entering ASCII sequences via the Alt-Numpad method in Windows).
 * No key typed events are generated for keys that don't generate Unicode
 * characters (e.g., action keys, modifier keys, etc.).
 * <p>
 * The getKeyChar method always returns a valid Unicode character or
 * CHAR_UNDEFINED.  Character input is reported by KEY_TYPED events:
 * KEY_PRESSED and KEY_RELEASED events are not necessarily associated
 * with character input.  Therefore, the result of the getKeyChar method
 * is guaranteed to be meaningful only for KEY_TYPED events.
 * <p>
 * For key pressed and key released events, the getKeyCode method returns
 * the event's keyCode.  For key typed events, the getKeyCode method
 * always returns {@code VK_UNDEFINED}. The {@code getExtendedKeyCode} method
 * may also be used with many international keyboard layouts.
 *
 * <p>
 * <em>"Key pressed" and "key released" events</em> are lower-level and depend
 * on the platform and keyboard layout. They are generated whenever a key is
 * pressed or released, and are the only way to find out about keys that don't
 * generate character input (e.g., action keys, modifier keys, etc.). The key
 * being pressed or released is indicated by the {@code getKeyCode} and {@code getExtendedKeyCode}
 * methods, which return a virtual key code.
 *
 * <p>
 * <em>Virtual key codes</em> are used to report which keyboard key has
 * been pressed, rather than a character generated by the combination
 * of one or more keystrokes (such as "A", which comes from shift and "a").
 *
 * <p>
 * For example, pressing the Shift key will cause a KEY_PRESSED event
 * with a VK_SHIFT keyCode, while pressing the 'a' key will result in
 * a VK_A keyCode.  After the 'a' key is released, a KEY_RELEASED event
 * will be fired with VK_A. Separately, a KEY_TYPED event with a keyChar
 * value of 'A' is generated.
 *
 * <p>
 * Pressing and releasing a key on the keyboard results in the generating
 * the following key events (in order):
 * <PRE>
 *    {@code KEY_PRESSED}
 *    {@code KEY_TYPED} (is only generated if a valid Unicode character could be generated.)
 *    {@code KEY_RELEASED}
 * </PRE>
 *
 * But in some cases (e.g. auto-repeat or input method is activated) the order
 * could be different (and platform dependent).
 *
 * <p>
 * Notes:
 * <ul>
 * <li>Key combinations which do not result in Unicode characters, such as action
 * keys like F1 and the HELP key, do not generate KEY_TYPED events.
 * <li>Not all keyboards or systems are capable of generating all
 * virtual key codes.  No attempt is made in Java to generate these keys
 * artificially.
 * <li>Virtual key codes do not identify a physical key: they depend on the
 * platform and keyboard layout. For example, the key that generates VK_Q
 * when using a U.S. keyboard layout will generate VK_A when using a French
 * keyboard layout.
 * <li>The key that generates {@code VK_Q} when using a U.S. keyboard layout also
 * generates a unique code for Russian or Hebrew layout. There is no a
 * {@code VK_} constant for these and many other codes in various layouts. These codes
 * may be obtained by using {@code getExtendedKeyCode} and are used whenever
 * a {@code VK_} constant is used.
 * <li>Not all characters have a keycode associated with them.  For example,
 * there is no keycode for the question mark because there is no keyboard
 * for which it appears on the primary layer.
 * <li>In order to support the platform-independent handling of action keys,
 * the Java platform uses a few additional virtual key constants for functions
 * that would otherwise have to be recognized by interpreting virtual key codes
 * and modifiers. For example, for Japanese Windows keyboards, VK_ALL_CANDIDATES
 * is returned instead of VK_CONVERT with the ALT modifier.
 * <li>As specified in <a href="../doc-files/FocusSpec.html">Focus Specification</a>
 * key events are dispatched to the focus owner by default.
 * </ul>
 *
 * <p>
 * WARNING: Aside from those keys that are defined by the Java language
 * (VK_ENTER, VK_BACK_SPACE, and VK_TAB), do not rely on the values of the VK_
 * constants.  Sun reserves the right to change these values as needed
 * to accomodate a wider range of keyboards in the future.
 * <p>
 * An unspecified behavior will be caused if the {@code id} parameter
 * of any particular {@code KeyEvent} instance is not
 * in the range from {@code KEY_FIRST} to {@code KEY_LAST}.
 *
 * @author Carl Quinn
 * @author Amy Fowler
 * @author Norbert Lindenberg
 *
 * @see KeyAdapter
 * @see KeyListener
 * @see <a href="http://java.sun.com/docs/books/tutorial/post1.0/ui/keylistener.html">Tutorial: Writing a Key Listener</a>
 *
 * @since 1.1
 */
public class KeyEvent extends InputEvent {
    private boolean isProxyActive = false;

    public static final int KEY_FIRST = 400;
    public static final int KEY_LAST  = 402;
    public static final int KEY_TYPED = KEY_FIRST;
    public static final int KEY_PRESSED = 1 + KEY_FIRST; //Event.KEY_PRESS
    public static final int KEY_RELEASED = 2 + KEY_FIRST; //Event.KEY_RELEASE
    public static final int VK_ENTER          = '\n';
    public static final int VK_BACK_SPACE     = '\b';
    public static final int VK_TAB            = '\t';
    public static final int VK_CANCEL         = 0x03;
    public static final int VK_CLEAR          = 0x0C;
    public static final int VK_SHIFT          = 0x10;
    public static final int VK_CONTROL        = 0x11;
    public static final int VK_ALT            = 0x12;
    public static final int VK_PAUSE          = 0x13;
    public static final int VK_CAPS_LOCK      = 0x14;
    public static final int VK_ESCAPE         = 0x1B;
    public static final int VK_SPACE          = 0x20;
    public static final int VK_PAGE_UP        = 0x21;
    public static final int VK_PAGE_DOWN      = 0x22;
    public static final int VK_END            = 0x23;
    public static final int VK_HOME           = 0x24;
    public static final int VK_LEFT           = 0x25;
    public static final int VK_UP             = 0x26;
    public static final int VK_RIGHT          = 0x27;
    public static final int VK_DOWN           = 0x28;
    public static final int VK_COMMA          = 0x2C;
    public static final int VK_MINUS          = 0x2D;
    public static final int VK_PERIOD         = 0x2E;
    public static final int VK_SLASH          = 0x2F;

    public static final int VK_0              = 0x30;
    public static final int VK_1              = 0x31;
    public static final int VK_2              = 0x32;
    public static final int VK_3              = 0x33;
    public static final int VK_4              = 0x34;
    public static final int VK_5              = 0x35;
    public static final int VK_6              = 0x36;
    public static final int VK_7              = 0x37;
    public static final int VK_8              = 0x38;
    public static final int VK_9              = 0x39;

    public static final int VK_SEMICOLON      = 0x3B;
    public static final int VK_EQUALS         = 0x3D;

    public static final int VK_A              = 0x41;
    public static final int VK_B              = 0x42;
    public static final int VK_C              = 0x43;
    public static final int VK_D              = 0x44;
    public static final int VK_E              = 0x45;
    public static final int VK_F              = 0x46;
    public static final int VK_G              = 0x47;
    public static final int VK_H              = 0x48;
    public static final int VK_I              = 0x49;
    public static final int VK_J              = 0x4A;
    public static final int VK_K              = 0x4B;
    public static final int VK_L              = 0x4C;
    public static final int VK_M              = 0x4D;
    public static final int VK_N              = 0x4E;
    public static final int VK_O              = 0x4F;
    public static final int VK_P              = 0x50;
    public static final int VK_Q              = 0x51;
    public static final int VK_R              = 0x52;
    public static final int VK_S              = 0x53;
    public static final int VK_T              = 0x54;
    public static final int VK_U              = 0x55;
    public static final int VK_V              = 0x56;
    public static final int VK_W              = 0x57;
    public static final int VK_X              = 0x58;
    public static final int VK_Y              = 0x59;
    public static final int VK_Z              = 0x5A;

    public static final int VK_OPEN_BRACKET   = 0x5B;
    public static final int VK_BACK_SLASH     = 0x5C;
    public static final int VK_CLOSE_BRACKET  = 0x5D;

    public static final int VK_NUMPAD0        = 0x60;
    public static final int VK_NUMPAD1        = 0x61;
    public static final int VK_NUMPAD2        = 0x62;
    public static final int VK_NUMPAD3        = 0x63;
    public static final int VK_NUMPAD4        = 0x64;
    public static final int VK_NUMPAD5        = 0x65;
    public static final int VK_NUMPAD6        = 0x66;
    public static final int VK_NUMPAD7        = 0x67;
    public static final int VK_NUMPAD8        = 0x68;
    public static final int VK_NUMPAD9        = 0x69;
    public static final int VK_MULTIPLY       = 0x6A;
    public static final int VK_ADD            = 0x6B;

    public static final int VK_SEPARATER      = 0x6C;
    public static final int VK_SEPARATOR      = VK_SEPARATER;

    public static final int VK_SUBTRACT       = 0x6D;
    public static final int VK_DECIMAL        = 0x6E;
    public static final int VK_DIVIDE         = 0x6F;
    public static final int VK_DELETE         = 0x7F; 
    public static final int VK_NUM_LOCK       = 0x90;
    public static final int VK_SCROLL_LOCK    = 0x91;

    public static final int VK_F1             = 0x70;
    public static final int VK_F2             = 0x71;
    public static final int VK_F3             = 0x72;
    public static final int VK_F4             = 0x73;
    public static final int VK_F5             = 0x74;
    public static final int VK_F6             = 0x75;
    public static final int VK_F7             = 0x76;
    public static final int VK_F8             = 0x77;
    public static final int VK_F9             = 0x78;
    public static final int VK_F10            = 0x79;
    public static final int VK_F11            = 0x7A;
    public static final int VK_F12            = 0x7B;
    public static final int VK_F13            = 0xF000;
    public static final int VK_F14            = 0xF001;
    public static final int VK_F15            = 0xF002;
    public static final int VK_F16            = 0xF003;
    public static final int VK_F17            = 0xF004;
    public static final int VK_F18            = 0xF005;
    public static final int VK_F19            = 0xF006;
    public static final int VK_F20            = 0xF007;
    public static final int VK_F21            = 0xF008;
    public static final int VK_F22            = 0xF009;
    public static final int VK_F23            = 0xF00A;
    public static final int VK_F24            = 0xF00B;

    public static final int VK_PRINTSCREEN    = 0x9A;
    public static final int VK_INSERT         = 0x9B;
    public static final int VK_HELP           = 0x9C;
    public static final int VK_META           = 0x9D;

    public static final int VK_BACK_QUOTE     = 0xC0;
    public static final int VK_QUOTE          = 0xDE;

    public static final int VK_KP_UP          = 0xE0;
    public static final int VK_KP_DOWN        = 0xE1;
    public static final int VK_KP_LEFT        = 0xE2;
    public static final int VK_KP_RIGHT       = 0xE3;

    public static final int VK_DEAD_GRAVE               = 0x80;
    public static final int VK_DEAD_ACUTE               = 0x81;
    public static final int VK_DEAD_CIRCUMFLEX          = 0x82;
    public static final int VK_DEAD_TILDE               = 0x83;
    public static final int VK_DEAD_MACRON              = 0x84;
    public static final int VK_DEAD_BREVE               = 0x85;
    public static final int VK_DEAD_ABOVEDOT            = 0x86;
    public static final int VK_DEAD_DIAERESIS           = 0x87;
    public static final int VK_DEAD_ABOVERING           = 0x88;
    public static final int VK_DEAD_DOUBLEACUTE         = 0x89;
    public static final int VK_DEAD_CARON               = 0x8a;
    public static final int VK_DEAD_CEDILLA             = 0x8b;
    public static final int VK_DEAD_OGONEK              = 0x8c;
    public static final int VK_DEAD_IOTA                = 0x8d;
    public static final int VK_DEAD_VOICED_SOUND        = 0x8e;
    public static final int VK_DEAD_SEMIVOICED_SOUND    = 0x8f;

    public static final int VK_AMPERSAND                = 0x96;
    public static final int VK_ASTERISK                 = 0x97;
    public static final int VK_QUOTEDBL                 = 0x98;
    public static final int VK_LESS                     = 0x99;
    public static final int VK_GREATER                  = 0xa0;
    public static final int VK_BRACELEFT                = 0xa1;
    public static final int VK_BRACERIGHT               = 0xa2;
    public static final int VK_AT                       = 0x0200;
    public static final int VK_COLON                    = 0x0201;
    public static final int VK_CIRCUMFLEX               = 0x0202;
    public static final int VK_DOLLAR                   = 0x0203;
    public static final int VK_EURO_SIGN                = 0x0204;
    public static final int VK_EXCLAMATION_MARK         = 0x0205;
    public static final int VK_INVERTED_EXCLAMATION_MARK = 0x0206;
    public static final int VK_LEFT_PARENTHESIS         = 0x0207;
    public static final int VK_NUMBER_SIGN              = 0x0208;
    public static final int VK_PLUS                     = 0x0209;
    public static final int VK_RIGHT_PARENTHESIS        = 0x020A;
    public static final int VK_UNDERSCORE               = 0x020B;
    public static final int VK_WINDOWS                  = 0x020C;
    public static final int VK_CONTEXT_MENU             = 0x020D;
    public static final int VK_FINAL                    = 0x0018;
    public static final int VK_CONVERT                  = 0x001C;
    public static final int VK_NONCONVERT               = 0x001D;
    public static final int VK_ACCEPT                   = 0x001E;
    public static final int VK_MODECHANGE               = 0x001F;
    public static final int VK_KANA                     = 0x0015;
    public static final int VK_KANJI                    = 0x0019;
    public static final int VK_ALPHANUMERIC             = 0x00F0;
    public static final int VK_KATAKANA                 = 0x00F1;
    public static final int VK_HIRAGANA                 = 0x00F2;
    public static final int VK_FULL_WIDTH               = 0x00F3;
    public static final int VK_HALF_WIDTH               = 0x00F4;
    public static final int VK_ROMAN_CHARACTERS         = 0x00F5;
    public static final int VK_ALL_CANDIDATES           = 0x0100;
    public static final int VK_PREVIOUS_CANDIDATE       = 0x0101;
    public static final int VK_CODE_INPUT               = 0x0102;
    public static final int VK_JAPANESE_KATAKANA        = 0x0103;
    public static final int VK_JAPANESE_HIRAGANA        = 0x0104;
    public static final int VK_JAPANESE_ROMAN           = 0x0105;
    public static final int VK_KANA_LOCK                = 0x0106;
    public static final int VK_INPUT_METHOD_ON_OFF      = 0x0107;

    public static final int VK_CUT                      = 0xFFD1;
    public static final int VK_COPY                     = 0xFFCD;
    public static final int VK_PASTE                    = 0xFFCF;
    public static final int VK_UNDO                     = 0xFFCB;
    public static final int VK_AGAIN                    = 0xFFC9;
    public static final int VK_FIND                     = 0xFFD0;
    public static final int VK_PROPS                    = 0xFFCA;
    public static final int VK_STOP                     = 0xFFC8;

    public static final int VK_COMPOSE                  = 0xFF20;
    public static final int VK_ALT_GRAPH                = 0xFF7E;
    public static final int VK_BEGIN                    = 0xFF58;
    public static final int VK_UNDEFINED      = 0x0;
    public static final char CHAR_UNDEFINED   = 0xFFFF;
    public static final int KEY_LOCATION_UNKNOWN  = 0;
    public static final int KEY_LOCATION_STANDARD = 1;
    public static final int KEY_LOCATION_LEFT     = 2;
    public static final int KEY_LOCATION_RIGHT    = 3;
    public static final int KEY_LOCATION_NUMPAD   = 4;

    int  keyCode;
    char keyChar;
    int keyLocation;

    private KeyEvent(Component source, int id, long when, int modifiers,
                    int keyCode, char keyChar, int keyLocation, boolean isProxyActive) {
        this(source, id, when, modifiers, keyCode, keyChar, keyLocation);
        this.isProxyActive = isProxyActive;
    }

    public KeyEvent(Component source, int id, long when, int modifiers,
                    int keyCode, char keyChar, int keyLocation) {
        super(source, id, when, modifiers);

        this.keyCode = keyCode;
        this.keyChar = keyChar;

        this.keyLocation = keyLocation;
    }

    public KeyEvent(Component source, int id, long when, int modifiers,
                    int keyCode, char keyChar) {
        this(source, id, when, modifiers, keyCode, keyChar,
          KEY_LOCATION_UNKNOWN);
    }

    public KeyEvent(Component source, int id, long when, int modifiers,
                    int keyCode) {
        this(source, id, when, modifiers, keyCode, (char)keyCode);
    }

    public int getKeyCode() {
        return keyCode;
    }

    public void setKeyCode(int keyCode) {
        this.keyCode = keyCode;
    }

    public char getKeyChar() {
        return keyChar;
    }

    public void setKeyChar(char keyChar) {
        this.keyChar = keyChar;
    }

    public void setModifiers(int modifiers) {
        this.modifiers = modifiers;
    }

    public int getKeyLocation() {
        return keyLocation;
    }

    public static String getKeyText(int keyCode) {
        if (keyCode >= VK_0 && keyCode <= VK_9 ||
            keyCode >= VK_A && keyCode <= VK_Z) {
            return String.valueOf((char)keyCode);
        }

        switch(keyCode) {
          case VK_ENTER: return "Enter";
          case VK_BACK_SPACE: return "Backspace";
          case VK_TAB: return "Tab";
          case VK_CANCEL: return "Cancel";
          case VK_CLEAR: return "Clear";
          case VK_COMPOSE: return "Compose";
          case VK_PAUSE: return "Pause";
          case VK_CAPS_LOCK: return "Caps Lock";
          case VK_ESCAPE: return "Escape";
          case VK_SPACE: return "Space";
          case VK_PAGE_UP: return "Page Up";
          case VK_PAGE_DOWN: return "Page Down";
          case VK_END: return "End";
          case VK_HOME: return "Home";
          case VK_LEFT: return "Left";
          case VK_UP: return "Up";
          case VK_RIGHT: return "Right";
          case VK_DOWN: return "Down";
          case VK_BEGIN: return "Begin";
          case VK_SHIFT: return "Shift";
          case VK_CONTROL: return "Control";
          case VK_ALT: return "Alt";
          case VK_META: return "Meta";
          case VK_ALT_GRAPH: return "Alt Graph";

          case VK_COMMA: return "Comma";
          case VK_PERIOD: return "Period";
          case VK_SLASH: return "Slash";
          case VK_SEMICOLON: return "Semicolon";
          case VK_EQUALS: return "Equals";
          case VK_OPEN_BRACKET: return "Open Bracket";
          case VK_BACK_SLASH: return "Back Slash";
          case VK_CLOSE_BRACKET: return "Close Bracket";

          case VK_MULTIPLY: return "NumPad *";
          case VK_ADD: return "NumPad +";
          case VK_SEPARATOR: return "NumPad ,";
          case VK_SUBTRACT: return "NumPad -";
          case VK_DECIMAL: return "NumPad .";
          case VK_DIVIDE: return "NumPad /";
          case VK_DELETE: return "Delete";
          case VK_NUM_LOCK: return "Num Lock";
          case VK_SCROLL_LOCK: return "Scroll Lock";

          case VK_WINDOWS: return "Windows";
          case VK_CONTEXT_MENU: return "Context Menu";

          case VK_F1: return "F1";
          case VK_F2: return "F2";
          case VK_F3: return "F3";
          case VK_F4: return "F4";
          case VK_F5: return "F5";
          case VK_F6: return "F6";
          case VK_F7: return "F7";
          case VK_F8: return "F8";
          case VK_F9: return "F9";
          case VK_F10: return "F10";
          case VK_F11: return "F11";
          case VK_F12: return "F12";


          case VK_AMPERSAND: return "Ampersand";
          case VK_ASTERISK: return "Asterisk";
          case VK_QUOTEDBL: return "Double Quote";
          case VK_LESS: return "Less";
          case VK_GREATER: return "Greater";
          case VK_BRACELEFT: return "Left Brace";
          case VK_BRACERIGHT: return "Right Brace";
          case VK_AT: return "At";
          case VK_COLON: return "Colon";
          case VK_CIRCUMFLEX: return "Circumflex";
          case VK_DOLLAR: return "Dollar";
          case VK_EURO_SIGN: return "Euro";
          case VK_MINUS: return "Minus";
          case VK_PLUS: return "Plus";
          case VK_UNDERSCORE: return "Underscore";
        }

        if (keyCode >= VK_NUMPAD0 && keyCode <= VK_NUMPAD9) {
            String numpad = "NumPad";
            char c = (char)(keyCode - VK_NUMPAD0 + '0');
            return numpad + "-" + c;
        }

        if ((keyCode & 0x01000000) != 0) {
            return String.valueOf((char)(keyCode ^ 0x01000000 ));
        }
        
        //added byHC
        if(keyCode == VK_PRINTSCREEN){
        	return "PrintScreen";
        }else if(keyCode == VK_INSERT){
        	return "Insert";
        }
        //end added
        
        String unknown = "Unknown";
        return unknown + " keyCode: 0x" + Integer.toString(keyCode, 16);
    }

    public static String getKeyModifiersText(int modifiers) {
        StringBuilder buf = new StringBuilder();
        if ((modifiers & InputEvent.META_MASK) != 0) {
            buf.append("Meta");
            buf.append("+");
        }
        if ((modifiers & InputEvent.CTRL_MASK) != 0) {
            buf.append("Ctrl");
            buf.append("+");
        }
        if ((modifiers & InputEvent.ALT_MASK) != 0) {
            buf.append("Alt");
            buf.append("+");
        }
        if ((modifiers & InputEvent.SHIFT_MASK) != 0) {
            buf.append("Shift");
            buf.append("+");
        }
        if ((modifiers & InputEvent.BUTTON1_MASK) != 0) {
            buf.append("Button1");
            buf.append("+");
        }
        if (buf.length() > 0) {
            buf.setLength(buf.length()-1);
        }
        return buf.toString();
    }

    public boolean isActionKey() {
        switch (keyCode) {
          case VK_HOME:
          case VK_END:
          case VK_PAGE_UP:
          case VK_PAGE_DOWN:
          case VK_UP:
          case VK_DOWN:
          case VK_LEFT:
          case VK_RIGHT:
          case VK_BEGIN:

          case VK_KP_LEFT:
          case VK_KP_UP:
          case VK_KP_RIGHT:
          case VK_KP_DOWN:

          case VK_F1:
          case VK_F2:
          case VK_F3:
          case VK_F4:
          case VK_F5:
          case VK_F6:
          case VK_F7:
          case VK_F8:
          case VK_F9:
          case VK_F10:
          case VK_F11:
          case VK_F12:
          case VK_F13:
          case VK_F14:
          case VK_F15:
          case VK_F16:
          case VK_F17:
          case VK_F18:
          case VK_F19:
          case VK_F20:
          case VK_F21:
          case VK_F22:
          case VK_F23:
          case VK_F24:
          case VK_PRINTSCREEN:
          case VK_SCROLL_LOCK:
          case VK_CAPS_LOCK:
          case VK_NUM_LOCK:
          case VK_PAUSE:
          case VK_INSERT:

          case VK_FINAL:
          case VK_CONVERT:
          case VK_NONCONVERT:
          case VK_ACCEPT:
          case VK_MODECHANGE:
          case VK_KANA:
          case VK_KANJI:
          case VK_ALPHANUMERIC:
          case VK_KATAKANA:
          case VK_HIRAGANA:
          case VK_FULL_WIDTH:
          case VK_HALF_WIDTH:
          case VK_ROMAN_CHARACTERS:
          case VK_ALL_CANDIDATES:
          case VK_PREVIOUS_CANDIDATE:
          case VK_CODE_INPUT:
          case VK_JAPANESE_KATAKANA:
          case VK_JAPANESE_HIRAGANA:
          case VK_JAPANESE_ROMAN:
          case VK_KANA_LOCK:
          case VK_INPUT_METHOD_ON_OFF:

          case VK_AGAIN:
          case VK_UNDO:
          case VK_COPY:
          case VK_PASTE:
          case VK_CUT:
          case VK_FIND:
          case VK_PROPS:
          case VK_STOP:

          case VK_HELP:
          case VK_WINDOWS:
          case VK_CONTEXT_MENU:
              return true;
        }
        return false;
    }

    public String paramString() {
        return "";
    }
    
    public  int getExtendedKeyCode() {
        return 0;
    }
    
    public static int getExtendedKeyCodeForChar(int c) {
        return 0;
    }

    private void readObject(ObjectInputStream s)
      throws IOException, ClassNotFoundException {
    }
}
